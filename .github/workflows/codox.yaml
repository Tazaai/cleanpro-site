name: Codox Diagnostics  Self-Healing
on:
  workflow_dispatch:
permissions:
  contents: write
name: Codox Diagnostics & Self-Healing
on:
workflow_dispatch:
permissions:
contents: write
name: Codox Diagnostics & Self-Healing
on:
workflow_dispatch:
on:
workflow_dispatch:   # âœ… Manual "Run workflow" button
permissions:
contents: write
jobs:
diagnostics:
runs-on: ubuntu-latest
timeout-minutes: 90
env:
GOOGLE_MAPS_API_KEY: ${{ secrets.GOOGLE_MAPS_API_KEY }}
GCP_PROJECT: ${{ secrets.GCP_PROJECT }}
GCP_SA_KEY: ${{ secrets.GCP_SA_KEY }}
GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
FIREBASE_KEY: ${{ secrets.FIREBASE_KEY }}
BACKEND_URL: "https://cleanpro-backend-5539254765.europe-west1.run.app"
steps:
# âœ… Sync latest code
- uses: actions/checkout@v4
- name: ğŸ§­ Sync latest code
run: |
git fetch origin main
git reset --hard origin/main
echo "âœ… Synced with latest main branch."
# âœ… Authenticate to Google Cloud
- name: ğŸ” Authenticate to Google Cloud
uses: google-github-actions/auth@v2
with:
credentials_json: ${{ secrets.GCP_SA_KEY }}
# âœ… Setup gcloud
- name: âš™ï¸ Setup gcloud
uses: google-github-actions/setup-gcloud@v2
with:
project_id: ${{ secrets.GCP_PROJECT }}
# âœ… Verify configuration
- name: ğŸ” Verify gcloud configuration
run: |
gcloud auth list
gcloud config set project "$GCP_PROJECT"
gcloud config set run/region europe-west1
gcloud info
# âœ… Install Codox CLI
- name: ğŸ§  Install Codox CLI
run: |
npm install -g codox prettier@3 || echo "âš ï¸ Codox CLI install warning"
sudo apt-get update -y
sudo apt-get install -y jq yamllint
codox --version || echo "â„¹ï¸ Codox CLI ready"
# âœ… Prepare diagnostic script
- name: ğŸ”§ Prepare diagnostic script
run: |
if [ -f ./review_report.sh ]; then
chmod +x ./review_report.sh
echo "âœ… review_report.sh ready"
else
echo "âŒ review_report.sh missing!"
exit 1
fi
# âœ… Validate secrets
- name: ğŸ—ï¸ Validate required secrets
run: |
secrets=(GOOGLE_MAPS_API_KEY GCP_PROJECT GCP_SA_KEY GITHUB_TOKEN)
missing=0
for s in "${secrets[@]}"; do
if [ -z "${!s}" ]; then
echo "âŒ Missing: $s"
missing=$((missing+1))
else
echo "âœ… $s OK"
fi
done
[ $missing -gt 0 ] && exit 1 || echo "âœ… All secrets verified"
# âœ… Self-heal backend Dockerfile
- name: ğŸ³ Self-heal backend Dockerfile
run: |
echo "ğŸ” Checking backend/Dockerfile..."
if [ -f backend/Dockerfile ]; then
sed -i 's#WORKDIR /app$#WORKDIR /app/backend#' backend/Dockerfile || true
grep -q 'EXPOSE 8080' backend/Dockerfile || echo 'EXPOSE 8080' >> backend/Dockerfile
grep -q 'CMD' backend/Dockerfile || echo 'CMD ["node","index.js"]' >> backend/Dockerfile
echo "âœ… Dockerfile verified and fixed if needed."
else
echo "âš ï¸ backend/Dockerfile not found â€” creating placeholder..."
cat > backend/Dockerfile <<'EOF'
FROM node:20-slim
WORKDIR /app
COPY . .
RUN npm install --production
EXPOSE 8080
CMD ["node","index.js"]
EOF
fi
# âœ… Detect or generate missing backend routes
- name: ğŸ§­ Detect or generate missing backend routes
run: |
echo "ğŸ” Scanning backend/routes for missing API files..."
mkdir -p backend/routes
routes=(services_api.mjs bookings_api.mjs quotes_api.mjs pricing_api.mjs)
for r in "${routes[@]}"; do
if [ ! -f "backend/routes/$r" ]; then
echo "âš™ï¸ Creating recovery route: $r"
echo 'import express from "express";' > "backend/routes/$r"
echo 'const router = express.Router();' >> "backend/routes/$r"
echo 'router.get("/", (req, res) => res.json({ message: "âœ… Auto-recovered route active" }));' >> "backend/routes/$r"
echo 'export default router;' >> "backend/routes/$r"
echo "âœ… $r created safely."
else
echo "âœ… $r exists â€” verified."
fi
done
# âœ… Validate YAML syntax
- name: ğŸ§© Validate YAML syntax
run: |
echo "ğŸ” Validating codox.yaml syntax..."
yamllint .github/workflows/codox.yaml || echo "âš ï¸ YAML validation warnings only"
# âœ… Validate frontend build
- name: ğŸ§± Validate frontend build
run: |
if [ -d frontend ]; then
echo "ğŸ§© Building frontend..."
cd frontend
if [ -f package.json ]; then
npm install --legacy-peer-deps
npm run build || echo "âš ï¸ Frontend build failed"
else
echo "â„¹ï¸ No package.json â€” skipping build"
fi
cd ..
else
echo "â„¹ï¸ No frontend directory â€” skipping build check"
fi
# âœ… Run diagnostic script
- name: ğŸ“‹ Run Codox diagnostic
run: |
echo "ğŸš€ Starting review_report.sh..."
./review_report.sh
# âœ… Commit diagnostic report
- name: ğŸ“¦ Commit diagnostic report
if: always()
run: |
git config user.email "codox-bot@users.noreply.github.com"
git config user.name "Codox Bot"
git add agent.md || true
git commit -m "chore: Codox diagnostic report update" || echo "â„¹ï¸ No report changes"
git push origin main || echo "âš ï¸ Push skipped"
# âœ… Commit auto-fixes & redeploy backend
- name: â™»ï¸ Commit Codox auto-fixes & redeploy
if: always()
run: |
git add backend/ frontend/ || true
git commit -m "chore: Codox auto-fix applied" || echo "â„¹ï¸ No fixes detected"
git push origin main || echo "âš ï¸ Push skipped"
if [ -f ./deploy_backend.sh ]; then
echo "ğŸš€ Running backend deploy (only 1 attempt)..."
bash ./deploy_backend.sh || echo "âš ï¸ Redeploy failed (non-fatal)"
else
echo "â„¹ï¸ deploy_backend.sh not found â€” skipping redeploy"
fi
# âœ… Verify backend health
- name: ğŸ©º Verify backend health
if: always()
run: |
echo "ğŸ©º Checking backend availability..."
STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$BACKEND_URL")
if [ "$STATUS" = "200" ]; then
echo "âœ… Backend healthy"
else
echo "âŒ Backend returned HTTP $STATUS"
exit 1
fi
# âœ… Global sanity check
- name: ğŸ§  Global sanity check
if: always()
run: |
grep -q "âŒ" agent.md && { echo "âŒ Errors found in diagnostics"; exit 1; }
echo "âœ… No critical errors detected"
# ğŸ¤– Codox Smart Agent (Universal AI Fixer)
- name: ğŸ¤– Codox Smart Agent
if: failure()
run: |
echo "ğŸš€ Running Codox GPT Smart Agent with memory..."
tail -n 200 agent.md > recent_errors.log
# Initialize or load memory
if [ ! -f codox_memory.json ]; then
echo '{"fixed_patterns":[],"run_count":0}' > codox_memory.json
fi
echo "ğŸ§© Checking for previously fixed patterns..."
MATCH=$(grep -Ff <(jq -r '.fixed_patterns[].pattern' codox_memory.json) recent_errors.log || true)
if [ -n "$MATCH" ]; then
echo "âš™ï¸ Error already known â€” skipping redundant GPT call."
else
echo "ğŸ§  Sending recent errors to GPT-4o-mini for adaptive universal fixes..."
curl -s https://api.openai.com/v1/chat/completions \
"model": "gpt-4o-mini",
-H "Content-Type: application/json" \
-H "Authorization: Bearer $OPENAI_API_KEY" \
-d "{
\"messages\": [
{\"role\": \"system\", \"content\": \"You are Codox Smart Agent. Read all logs and fix *any kind* of system, code, YAML, Docker, deployment, or config error safely using bash.\"},
{\"role\": \"user\", \"content\": \"$(cat recent_errors.log | sed 's/\"/\\"/g')\"}
],
\"max_tokens\": 700
}" | jq -r '.choices[0].message.content' > codox_ai_fix.sh
echo "ğŸ›  Applying AI fixes..."
grep -E '^(sudo|echo|cp|mv|sed|npm|gcloud|docker|bash|cat|touch|chmod|mkdir)' codox_ai_fix.sh > codox_ai_safe.sh
chmod +x codox_ai_safe.sh
bash codox_ai_safe.sh || echo "âš ï¸ Some AI fixes failed but continuing."
echo "ğŸ§  Updating memory..."
jq --arg pat "$(head -n 1 recent_errors.log | tr -d '\n')" \
'.fixed_patterns += [{"pattern":$pat,"time":"'"$(date)"'"}] | .run_count += 1' \
codox_memory.json > tmp && mv tmp codox_memory.json
fi
echo "ğŸ” Re-running diagnostics..."
bash ./review_report.sh || echo "âš ï¸ Diagnostics still show issues."
echo "âœ… Codox Smart Agent finished with universal memory tracking."
env:
OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
# âœ… Upload diagnostic log
- name: ğŸ“¤ Upload diagnostic log
if: always()
uses: actions/upload-artifact@v4
with:
name: codox-diagnostics-log
path: agent.md
